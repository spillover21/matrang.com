<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MATRANG DOGS</title>
    <meta name="description" content="–ø–∏—Ç–æ–º–Ω–∏–∫ –∞–º–µ—Ä–∏–∫–∞–Ω—Å–∫–∏—Ö –±—É–ª–ª–∏ Great Legacy bully" />
    <meta name="author" content="MATRANG Kennel" />

    <meta property="og:title" content="MATRANG" />
    <meta property="og:description" content="–ø–∏—Ç–æ–º–Ω–∏–∫ –∞–º–µ—Ä–∏–∫–∞–Ω—Å–∫–∏—Ö –±—É–ª–ª–∏ Great Legacy bully" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://matrang.com/" />
    <meta property="og:image" content="https://matrang.com/uploads/1767891439_85337ea8.png" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@MATRANG" />
    <meta name="twitter:image" content="/assets/hero-pitbull.jpg" />
    
    <script>
      // DEBUG: –ü–µ—Ä–µ—Ö–≤–∞—Ç –∫–ª–∏–∫–æ–≤ –Ω–∞ –≤—Å–µ—Ö –∫–Ω–æ–ø–∫–∞—Ö
      window.addEventListener('DOMContentLoaded', function() {
        console.error('üü¢ DEBUG SCRIPT LOADED at ' + new Date().toISOString());
        
        setInterval(function() {
          const sendButton = Array.from(document.querySelectorAll('button')).find(btn => 
            btn.textContent && (btn.textContent.includes('–û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ email') || btn.textContent.includes('–û—Ç–ø—Ä–∞–≤–∫–∞'))
          );
          
          if (sendButton && !sendButton.dataset.debugAttached) {
            sendButton.dataset.debugAttached = 'true';
            console.error('üîµ Found send button, attaching debug listener');
            
            sendButton.addEventListener('click', function(e) {
              console.error('üî¥üî¥üî¥ BUTTON CLICKED!', e);
              alert('üî¥ BUTTON CLICKED! Time: ' + Date.now());
              window.__BUTTON_CLICKED = Date.now();
            }, true); // capture phase
          }
        }, 1000);
      });
    </script>




    <script type="module" crossorigin src="/assets/index-sKnweAqN-1769466368072.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-D35cW1RB.css">
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  </head>

  <body>
    <div id="root"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
      #vanilla-contract-ui input, #vanilla-contract-ui button { transition: all 0.2s; }
      #vanilla-contract-ui button:active { transform: scale(0.95); }
    </style>
  </head>

  <body>
    <div id="root"></div>
    
    <!-- VANILLA JS BRIDGE - TOP BAR TOOLBAR -->
    <div id="vanilla-contract-ui" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 50px; background: #1e293b; border-bottom: 2px solid #3b82f6; z-index: 99999; box-shadow: 0 4px 10px rgba(0,0,0,0.3); align-items: center; padding: 0 20px; box-sizing: border-box; font-family: sans-serif; color: white;">
      <div style="font-weight:bold; color: #60a5fa; margin-right: 20px; font-size: 14px;">‚ö° MATRANG PDF</div>
      
      <div id="vanilla-pdf-status" style="font-size: 12px; color: #94a3b8; margin-right: 20px;">
        ‚è≥ –ü–æ–∏—Å–∫...
      </div>

      <div style="display:flex; gap: 8px; margin-right: auto;">
         <button id="btn-save-profile" style="font-size: 12px; padding: 6px 10px; background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; cursor: pointer;">üíæ C–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–æ–∏ –¥–∞–Ω–Ω—ã–µ</button>
         <button id="btn-load-profile" style="font-size: 12px; padding: 6px 10px; background: #334155; color: white; border: 1px solid #475569; border-radius: 4px; cursor: pointer;">üì• –í—Å—Ç–∞–≤–∏—Ç—å –º–æ–∏ –¥–∞–Ω–Ω—ã–µ</button>
      </div>

      <div style="display:flex; gap: 8px; align-items: center;">
          <span id="vanilla-status" style="font-size: 11px; color: #fbbf24; margin-right: 10px; opacity: 0;">...</span>
          <button id="vanilla-fill-btn" style="font-size: 12px; padding: 6px 12px; background: #2563eb; color: white; border: none; border-radius: 4px; font-weight: bold; cursor: pointer;">1. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å PDF</button>
          <button id="vanilla-download-btn" style="font-size: 12px; padding: 6px 12px; background: #059669; color: white; border: none; border-radius: 4px; font-weight: bold; cursor: pointer;">2. –°–∫–∞—á–∞—Ç—å</button>
          <button id="vanilla-send-btn" style="font-size: 12px; padding: 6px 12px; background: #dc2626; color: white; border: none; border-radius: 4px; font-weight: bold; cursor: pointer;">3. –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –ø–æ–¥–ø–∏—Å—å</button>
      </div>
    </div>
    
    <script>
    (function() {
      const { PDFDocument } = PDFLib;
      let filledPdfBytes = null;
      let pdfTemplatePath = null;
      
      const statusEl = document.getElementById('vanilla-status');
      const setStatus = (msg) => { statusEl.textContent = msg; console.log('[VANILLA]', msg); };
      
      // Helper to find input by placeholder
      const getValByPlaceholder = (ph, index = 0) => {
        const els = document.querySelectorAll(`input[placeholder="${ph}"], textarea[placeholder="${ph}"]`);
        return els[index] ? els[index].value : '';
      };
      
      const getValByPlaceholderEx = (ph, index = 0) => {
         const els = document.querySelectorAll(`input[placeholder="${ph}"]`);
         return els[index] ? els[index].value : '';
      };

      // Date formatter
      const formatDate = (isoDate) => {
          if (!isoDate || !isoDate.includes('-')) return isoDate;
          const [y, m, d] = isoDate.split('-');
          return `${d}.${m}.${y}`;
      };

      // Helper to find input/select/textarea by Label text
      const getValByLabel = (labelText, type = 'text', index = 0) => {
        // Find labels loosely matching text (Using innerText as textContent can be hidden)
        const labels = Array.from(document.querySelectorAll('label'))
            .filter(l => l.innerText && l.innerText.includes(labelText));
        
        const labelEl = labels[index]; 
        if (!labelEl) {
            console.warn(`[VANILLA] Label NOT FOUND: "${labelText}" (index ${index})`);
            return '';
        }
        
        const parent = labelEl.parentElement;
        if (!parent) return '';

        let input;
        if (type === 'checkbox') {
             input = parent.querySelector('input[type="checkbox"]') || labelEl.querySelector('input[type="checkbox"]');
             return input ? input.checked : false;
        }

        input = parent.querySelector('input, select, textarea');
        let val = input ? input.value : '';
        
        // Auto-format dates
        if (input && input.type === 'date' && val) {
            val = formatDate(val);
        }
        
        console.log(`[VANILLA] Scraped "${labelText}" [${index}]: "${val}"`);
        return val;
      };
      
      // *** HACK: Change date input to text to allow custom text ***
      setInterval(() => {
         const labels = Array.from(document.querySelectorAll('label'));
         const labelEl = labels.find(l => l.innerText.includes('–°—Ä–æ–∫ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–∞—Å—á–µ—Ç–∞'));
         if (labelEl && labelEl.parentElement) {
            const dateInput = labelEl.parentElement.querySelector('input[type="date"]');
            if (dateInput) {
                console.log('[VANILLA] Converting "Final Payment" date input to text');
                dateInput.type = 'text';
                dateInput.placeholder = '–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏–ª–∏ —É—Å–ª–æ–≤–∏—è...';
            }
         }
      }, 2000);

      const getHeaders = () => {
        const token = localStorage.getItem("admin_token");
        return token ? { 'Authorization': `Bearer ${token}` } : {};
      };
      
      async function checkPdfTemplate() {
        // VISIBILITY CHECK: Only show in Admin Panel
        const ui = document.getElementById('vanilla-contract-ui');
        if (ui) {
            if (window.location.href.includes('/admin')) {
                ui.style.display = 'block';
            } else {
                ui.style.display = 'none';
                return; // Stop processing if not in admin
            }
        }

        try {
          const headers = getHeaders();
          if (!headers.Authorization) {
            const statusDiv = document.getElementById('vanilla-pdf-status');
            statusDiv.innerHTML = 'üîí <b>–í–æ–π–¥–∏—Ç–µ –≤ –∞–¥–º–∏–Ω–∫—É</b>';
            statusDiv.style.background = '#f3f4f6';
            return;
          }
          
          const res = await fetch('/api/api.php?action=getContracts', { headers });
          const data = await res.json();
          const statusDiv = document.getElementById('vanilla-pdf-status');
          
          if (data.success && data.pdfTemplate) {
            pdfTemplatePath = data.pdfTemplate;
            statusDiv.innerHTML = '‚úÖ <b>–®–∞–±–ª–æ–Ω –Ω–∞–π–¥–µ–Ω!</b><br>–ú–æ–∂–Ω–æ –∑–∞–ø–æ–ª–Ω—è—Ç—å.';
            statusDiv.style.background = '#d1fae5';
            statusDiv.style.borderColor = '#34d399';
          } else {
            statusDiv.innerHTML = '‚ö†Ô∏è <b>–®–∞–±–ª–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω.</b><br>–ó–∞–≥—Ä—É–∑–∏—Ç–µ PDF –≤ –∞–¥–º–∏–Ω–∫–µ.';
            statusDiv.style.background = '#fee2e2';
            statusDiv.style.borderColor = '#f87171';
          }
        } catch (e) { console.error(e); }
      }
      setInterval(checkPdfTemplate, 3000);
      checkPdfTemplate();

      setInterval(checkPdfTemplate, 3000);
      checkPdfTemplate();

      // Helper to scrape only Seller info
      const scrapeSellerInfo = () => {
          return {
             kennelOwner: getValByLabel('–í–ª–∞–¥–µ–ª–µ—Ü –ø–∏—Ç–æ–º–Ω–∏–∫–∞'), 
             kennelAddress: getValByLabel('–ê–¥—Ä–µ—Å', 'text', 0), 
             kennelPhone: getValByLabel('–¢–µ–ª–µ—Ñ–æ–Ω', 'text', 0),
             kennelEmail: getValByLabel('Email', 'text', 0),
             kennelPassportSeries: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç —Å–µ—Ä–∏—è', 'text', 0),
             kennelPassportNumber: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –Ω–æ–º–µ—Ä', 'text', 0),
             kennelPassportIssuedBy: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –≤—ã–¥–∞–Ω', 'text', 0),
             // Note: getValByLabel returns formatted date "DD.MM.YYYY". We save this.
             kennelPassportIssuedDate: getValByLabel('–î–∞—Ç–∞ –≤—ã–¥–∞—á–∏ –ø–∞—Å–ø–æ—Ä—Ç–∞', 'date', 0)
          };
      };

      // Helper to set input by Label
      const setValByLabel = (labelText, value, index = 0) => {
         const labels = Array.from(document.querySelectorAll('label'))
            .filter(l => l.innerText && l.innerText.includes(labelText));
         const labelEl = labels[index];
         if (!labelEl) return;
         
         const parent = labelEl.parentElement;
         if (!parent) return;
         
         const input = parent.querySelector('input, select, textarea');
         if (input) {
             // For React 16+ controlled components hack
             const proto = Object.getPrototypeOf(input);
             const setter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
             
             if (setter) {
                 setter.call(input, value);
             } else {
                 input.value = value;
             }
             
             input.dispatchEvent(new Event('input', { bubbles: true }));
             input.dispatchEvent(new Event('change', { bubbles: true }));
             console.log(`[VANILLA] Set "${labelText}" to "${value}"`);
         }
      };

      document.getElementById('btn-save-profile').addEventListener('click', async () => {
         const data = scrapeSellerInfo();
         if (!data.kennelOwner) { alert('‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –§–ò–û –∏ –¥—Ä—É–≥–∏–µ —Å–≤–æ–∏ –¥–∞–Ω–Ω—ã–µ, –∑–∞—Ç–µ–º –∂–º–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ.'); return; }
         
         try {
             setStatus('–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...');
             await fetch('/api/api.php?action=save_seller_profile', {
                 method: 'POST',
                 headers: getHeaders(),
                 body: JSON.stringify(data)
             });
             alert('‚úÖ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã! –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –Ω–µ –≤–≤–æ–¥–∏—Ç—å –∏—Ö –≤—Ä—É—á–Ω—É—é.');
             setStatus('‚úÖ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
         } catch(e) { alert('Error: ' + e.message); }
      });

      document.getElementById('btn-load-profile').addEventListener('click', async () => {
         try {
             setStatus('–ó–∞–≥—Ä—É–∑–∫–∞...');
             const res = await fetch('/api/api.php?action=get_seller_profile', { headers: getHeaders() });
             let data = await res.json();
             
             if (!data || Object.keys(data).length === 0) {
                 alert('‚ö†Ô∏è –ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è –∏ –Ω–∞–∂–º–∏—Ç–µ "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –º–æ–∏ –¥–∞–Ω–Ω—ã–µ".');
                 return;
             }
             
             // Check if it's the old format or new (handle both just in case)
             console.log('Loading profile:', data);

             setValByLabel('–í–ª–∞–¥–µ–ª–µ—Ü –ø–∏—Ç–æ–º–Ω–∏–∫–∞', data.kennelOwner || '');
             setValByLabel('–ê–¥—Ä–µ—Å', data.kennelAddress || '', 0);
             setValByLabel('–¢–µ–ª–µ—Ñ–æ–Ω', data.kennelPhone || '', 0);
             setValByLabel('Email', data.kennelEmail || '', 0);
             setValByLabel('–ü–∞—Å–ø–æ—Ä—Ç —Å–µ—Ä–∏—è', data.kennelPassportSeries || '', 0);
             setValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –Ω–æ–º–µ—Ä', data.kennelPassportNumber || '', 0);
             setValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –≤—ã–¥–∞–Ω', data.kennelPassportIssuedBy || '', 0);
             
             // Restore Date: stored as DD.MM.YYYY, input needs YYYY-MM-DD
             let dateVal = data.kennelPassportIssuedDate;
             if (dateVal && dateVal.includes('.')) {
                 const [d, m, y] = dateVal.split('.');
                 dateVal = `${y}-${m}-${d}`;
             }
             setValByLabel('–î–∞—Ç–∞ –≤—ã–¥–∞—á–∏ –ø–∞—Å–ø–æ—Ä—Ç–∞', dateVal || '', 0);
             
             alert('‚úÖ –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –≤—Å—Ç–∞–≤–ª–µ–Ω—ã!');
             setStatus('‚úÖ –ì–æ—Ç–æ–≤–æ');
         } catch(e) { console.error(e); alert('Error loading profile: ' + e.message); }
      });
      
      document.getElementById('vanilla-fill-btn').innerHTML = '1. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å PDF';
      document.getElementById('vanilla-fill-btn').addEventListener('click', async () => {
        if (!pdfTemplatePath) { alert('‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ PDF —à–∞–±–ª–æ–Ω –≤ –∞–¥–º–∏–Ω–∫–µ (—Å–ª–µ–≤–∞)!'); return; }
        
        try {
          setStatus('‚è≥ –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö (v5)...');
          console.clear();
          console.log('[VANILLA] START SCRAPING (v5)...');

          const contractNum = `DOG-${new Date().getFullYear()}-${String(Math.floor(Math.random() * 9999) + 1).padStart(4, '0')}`;

          // Robust scraping using Labels where possible (more reliable than placeholders)
          const data = {
            // == KENNEL (Index 0) ==
            kennelName: getValByPlaceholder('GREAT LEGACY BULLY') || 'GREAT LEGACY BULLY',
            kennelOwner: getValByLabel('–í–ª–∞–¥–µ–ª–µ—Ü –ø–∏—Ç–æ–º–Ω–∏–∫–∞'), 
            kennelAddress: getValByLabel('–ê–¥—Ä–µ—Å', 'text', 0), 
            kennelPhone: getValByLabel('–¢–µ–ª–µ—Ñ–æ–Ω', 'text', 0),
            kennelEmail: getValByLabel('Email', 'text', 0),
            
            // Kennel Passport - Double check retrieval
            kennelPassportSeries: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç —Å–µ—Ä–∏—è', 'text', 0) || getValByPlaceholderEx('1234', 0),
            kennelPassportNumber: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –Ω–æ–º–µ—Ä', 'text', 0) || getValByPlaceholderEx('567890', 0),
            kennelPassportIssuedBy: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –≤—ã–¥–∞–Ω', 'text', 0) || getValByPlaceholderEx('–£–§–ú–°...', 0),
            
            // Kennel Date: Explicitly get the first date input if label fails (Index 0 is usually kennel)
            kennelPassportIssuedDate: getValByLabel('–î–∞—Ç–∞ –≤—ã–¥–∞—á–∏ –ø–∞—Å–ø–æ—Ä—Ç–∞', 'date', 0) || formatDate(document.querySelectorAll('input[type="date"]')[0]?.value),
            
            // == BUYER (Index 1) ==
            buyerName: getValByLabel('–§–ò–û –ø–æ–∫—É–ø–∞—Ç–µ–ª—è'),
            buyerAddress: getValByLabel('–ê–¥—Ä–µ—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏'),
            buyerPhone: getValByLabel('–¢–µ–ª–µ—Ñ–æ–Ω', 'text', 1),
            buyerEmail: getValByLabel('Email', 'text', 1),
            
            // Buyer Pasport
            buyerPassportSeries: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç —Å–µ—Ä–∏—è', 'text', 1) || getValByPlaceholderEx('1234', 1),
            buyerPassportNumber: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –Ω–æ–º–µ—Ä', 'text', 1) || getValByPlaceholderEx('567890', 1),
            buyerPassportIssuedBy: getValByLabel('–ü–∞—Å–ø–æ—Ä—Ç –≤—ã–¥–∞–Ω', 'text', 1) || getValByPlaceholderEx('–£–§–ú–°...', 1),
            buyerPassportIssuedDate: getValByLabel('–î–∞—Ç–∞ –≤—ã–¥–∞—á–∏ –ø–∞—Å–ø–æ—Ä—Ç–∞', 'date', 1),

            // Checking specific email label for buyer if generic 'Email' fails
            _buyerEmailFallback: getValByLabel('Email –ø–æ–∫—É–ø–∞—Ç–µ–ª—è', 'text', 0),

             // Parents
            dogFatherName: getValByLabel('–ö–ª–∏—á–∫–∞ –æ—Ç—Ü–∞'),
            dogFatherRegNumber: getValByLabel('–†–µ–≥. –Ω–æ–º–µ—Ä –æ—Ç—Ü–∞'),
            dogMotherName: getValByLabel('–ö–ª–∏—á–∫–∞ –º–∞—Ç–µ—Ä–∏'),
            dogMotherRegNumber: getValByLabel('–†–µ–≥. –Ω–æ–º–µ—Ä –º–∞—Ç–µ—Ä–∏'),

            // Dog
            dogName: getValByLabel('–ö–ª–∏—á–∫–∞ —â–µ–Ω–∫–∞'),
            dogBreed: getValByLabel('–ü–æ—Ä–æ–¥–∞'),
            dogBirthDate: getValByLabel('–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è'),
            dogGender: getValByLabel('–ü–æ–ª'),
            dogColor: getValByLabel('–û–∫—Ä–∞—Å'),
            dogChipNumber: getValByLabel('–ù–æ–º–µ—Ä —á–∏–ø–∞'),
            dogPuppyCard: getValByLabel('–©–µ–Ω—è—á—å—è –∫–∞—Ä—Ç–æ—á–∫–∞'),

            // Financial
            price: getValByLabel('–ü–æ–ª–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å'),
            depositAmount: getValByLabel('–°—É–º–º–∞ –∑–∞–¥–∞—Ç–∫–∞'),
            depositDate: getValByLabel('–î–∞—Ç–∞ –≤–Ω–µ—Å–µ–Ω–∏—è –∑–∞–¥–∞—Ç–∫–∞'),
            remainingAmount: getValByLabel('–û—Å—Ç–∞—Ç–æ–∫ –∫ –æ–ø–ª–∞—Ç–µ'), 
            finalPaymentDate: getValByLabel('–°—Ä–æ–∫ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–∞—Å—á–µ—Ç–∞'),

            // Medical
            dewormingDate: getValByLabel('–î–∞—Ç–∞ –≤—ã–≥–æ–Ω–∫–∏ –≥–ª–∏—Å—Ç–æ–≤'),
            vaccinationDates: getValByLabel('–î–∞—Ç—ã –ø—Ä–∏–≤–∏–≤–æ–∫'),
            vaccineName: getValByLabel('–ù–∞–∑–≤–∞–Ω–∏–µ –≤–∞–∫—Ü–∏–Ω—ã'),
            nextDewormingDate: getValByLabel('–°–ª–µ–¥—É—é—â–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç –≥–ª–∏—Å—Ç–æ–≤'),
            nextVaccinationDate: getValByLabel('–°–ª–µ–¥—É—é—â–∞—è –≤–∞–∫—Ü–∏–Ω–∞—Ü–∏—è'),
            
            purposeBreeding: getValByLabel('–î–ª—è –ø–ª–µ–º–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã', 'checkbox'),
            purposeCompanion: getValByLabel('–ö–æ–º–ø–∞–Ω—å–æ–Ω', 'checkbox'),
            purposeGeneral: getValByLabel('–û–±—â–µ–Ω–∏–µ', 'checkbox'),
            
            specialFeatures: getValByLabel('–ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏'),
            deliveryTerms: getValByLabel('–£—Å–ª–æ–≤–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏'),
            additionalAgreements: getValByLabel('–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è'),
            recommendedFood: getValByLabel('–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –∫–æ—Ä–º'),
            
            contractDate: getValByLabel('–î–∞—Ç–∞ –¥–æ–≥–æ–≤–æ—Ä–∞') || new Date().toLocaleDateString('ru-RU'),
            contractPlace: getValByLabel('–ú–µ—Å—Ç–æ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è'),
            contractNumber: contractNum
          };
          
          // Fixup logic
          if (!data.buyerEmail && data._buyerEmailFallback) {
             data.buyerEmail = data._buyerEmailFallback;
          }
           // Fallbacks
          if (!data.buyerEmail) data.buyerEmail = getValByPlaceholder('buyer@email.com');
          if (!data.kennelPhone) data.kennelPhone = getValByPlaceholder('+7 (900) 455-27-16');

          console.log('[VANILLA] Scraped Data Final:', data);
          if(!data.buyerEmail) { alert('‚ö†Ô∏è Email –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–ª–µ.'); }

          const pdfBytes = await fetch(pdfTemplatePath).then(res => res.arrayBuffer());
          const pdfDoc = await PDFDocument.load(pdfBytes);
          const form = pdfDoc.getForm();
          
          // DEBUG: Log ALL available PDF fields to find the correct name
          const pFields = form.getFields().map(f => f.getName());
          console.log('[DEBUG] AVAILABLE PDF FIELDS:', pFields);

          const fieldMap = {
            '`contractNumber`': data.contractNumber, // Added
            
            '`kennelName`': data.kennelName,
            '`kennelOwner`': data.kennelOwner,
            '`kennelAddress`': data.kennelAddress,
            '`kennelPhone`': data.kennelPhone,
            '`kennelEmail`': data.kennelEmail,
            '`kennelPassportSeries`': data.kennelPassportSeries, 
            '`kennelPassportNumber`': data.kennelPassportNumber,
            '`kennelPassportIssuedBy`': data.kennelPassportIssuedBy,
            '`kennelPassportIssuedDate': data.kennelPassportIssuedDate, // Fixed: Missing backtick in PDF template field name
            
            '`buyerName`': data.buyerName,
            '`buyerAddress`': data.buyerAddress,
            '`buyerPhone`': data.buyerPhone,
            '`buyerEmail`': data.buyerEmail,
            '`buyerPassportSeries`': data.buyerPassportSeries,
            '`buyerPassportNumber`': data.buyerPassportNumber,
            '`buyerPassportIssuedBy`': data.buyerPassportIssuedBy,
            '`buyerPassportIssuedDate`': data.buyerPassportIssuedDate,

            '`dogFatherName`': data.dogFatherName,
            '`dogFatherRegNumber`': data.dogFatherRegNumber,
            '`dogMotherName`': data.dogMotherName,
            '`dogMotherRegNumber`': data.dogMotherRegNumber,

            '`dogName`': data.dogName,
            '`dogBreed`': data.dogBreed,
            '`dogBirthDate`': data.dogBirthDate,
            '`dogGender`': data.dogGender,
            '`dogColor`': data.dogColor,
            '`dogChipNumber`': data.dogChipNumber,
            '`dogPuppyCard`': data.dogPuppyCard,

            '`purposeBreeding`': data.purposeBreeding,
            '`purposeCompanion`': data.purposeCompanion,
            '`purposeGeneral`': data.purposeGeneral,

            '`price`': data.price,
            '`depositAmount`': data.depositAmount,
            '`depositDate`': data.depositDate,
            '`remainingAmount`': data.remainingAmount,
            '`finalPaymentDate`': data.finalPaymentDate,

            '`dewormingDate`': data.dewormingDate,
            '`vaccinationDates`': data.vaccinationDates,
            '`vaccineName`': data.vaccineName,
            '`nextDewormingDate`': data.nextDewormingDate,
            '`nextVaccinationDate`': data.nextVaccinationDate,

            '`specialFeatures`': data.specialFeatures,
            '`deliveryTerms`': data.deliveryTerms,
            '`additionalAgreements`': data.additionalAgreements,
            '`recommendedFood`': data.recommendedFood,

            '`contractDate`': data.contractDate,
            '`contractPlace`': data.contractPlace
          };

          let filledCount = 0;
          for (const [name, val] of Object.entries(fieldMap)) {
            try {
              if (typeof val === 'boolean') {
                 const cb = form.getCheckBox(name);
                 val ? cb.check() : cb.uncheck();
                 filledCount++;
              } else {
                 form.getTextField(name).setText(String(val || ''));
                 filledCount++;
              }
            } catch (e) {
               try {
                 // Try stripping backticks if needed, though map has them
                 const cleanName = name.replace(/`/g, '');
                 if (typeof val === 'boolean') {
                    const cb = form.getCheckBox(cleanName);
                    val ? cb.check() : cb.uncheck();
                 } else {
                    form.getTextField(cleanName).setText(String(val || ''));
                 }
                 filledCount++;
               } catch (e2) {
                   console.warn(`[DEBUG] ‚ö†Ô∏è –ù–ï –ù–ê–ô–î–ï–ù–û –ü–û–õ–ï –í PDF: "${name}" (–ø—ã—Ç–∞–ª–∏—Å—å –∑–∞–ø–∏—Å–∞—Ç—å: "${val}")`);
               }
            }
          }

          // Force NeedAppearances - ABSOLUTELY CRITICAL
          try {
             const acroForm = pdfDoc.catalog.lookup(PDFLib.PDFName.of('AcroForm'));
             if (acroForm) {
                acroForm.set(PDFLib.PDFName.of('NeedAppearances'), PDFLib.PDFBool.True);
                console.log('[DEBUG] NeedAppearances set to TRUE');
             }
          } catch(e) { console.error('[DEBUG] NeedAppearances error:', e); }

          // Validate filled PDF bytes
          filledPdfBytes = await pdfDoc.save({ updateFieldAppearances: false });
          console.log('[DEBUG] PDF saved, bytes:', filledPdfBytes.byteLength);
          
          setStatus(`‚úÖ –ó–∞–ø–æ–ª–Ω–µ–Ω–æ –ø–æ–ª–µ–π: ${filledCount}`);
          alert(`‚úÖ –£—Å–ø–µ—à–Ω–æ! –ó–∞–ø–æ–ª–Ω–µ–Ω–æ ${filledCount} –ø–æ–ª–µ–π.\n–ù–∞–∂–º–∏—Ç–µ "–°–∫–∞—á–∞—Ç—å" –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.`);
          
        } catch (err) {
          setStatus('‚ùå –û—à–∏–±–∫–∞: ' + err.message);
          alert('–û—à–∏–±–∫–∞: ' + err.message);
        }
      });
      
      document.getElementById('vanilla-download-btn').addEventListener('click', () => {
        if (!filledPdfBytes) { alert('–°–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏—Ç–µ "–ó–∞–ø–æ–ª–Ω–∏—Ç—å"!'); return; }
        const blob = new Blob([filledPdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `contract_${Date.now()}.pdf`;
        a.click();
      });
      
      document.getElementById('vanilla-send-btn').addEventListener('click', async () => {
         if (!filledPdfBytes) { alert('‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ PDF (–∫–Ω–æ–ø–∫–∞ 1)!'); return; }
         
         const clientEmail = prompt('–í–≤–µ–¥–∏—Ç–µ Email –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏:', document.querySelector('input[placeholder="buyer@email.com"]')?.value || '');
         if (!clientEmail) return;
         
         if (!confirm(`–û—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–æ–≥–æ–≤–æ—Ä –Ω–∞ –ø–æ–¥–ø–∏—Å—å –∫–ª–∏–µ–Ω—Ç—É: ${clientEmail}?`)) return;

         try {
             setStatus('‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä...');
             const base64Pdf = await blobToBase64(new Blob([filledPdfBytes], {type: 'application/pdf'}));
             
             // 1. Upload
             const upRes = await fetch('/api/api.php?action=upload_pdf_for_signing', {
                 method: 'POST',
                 headers: getHeaders(),
                 body: JSON.stringify({ pdfBase64: base64Pdf, clientEmail })
             });
             const upData = await upRes.json();
             
             if (!upData.success) throw new Error(upData.message || 'Upload failed');
             
             setStatus('‚è≥ –û—Ç–ø—Ä–∞–≤–∫–∞ –ø–∏—Å—å–º–∞...');
             // 2. Send Email
             const mailRes = await fetch('/api/api.php?action=send_signing_email', {
                 method: 'POST',
                 headers: getHeaders(),
                 body: JSON.stringify({ email: clientEmail, link: upData.link })
             });
             const mailData = await mailRes.json();
             
             if (mailData.success) {
                 alert('‚úÖ –ü–∏—Å—å–º–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–ª–∏–µ–Ω—Ç—É!\n–°—Å—ã–ª–∫–∞: ' + upData.link);
                 setStatus('‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!');
             } else {
                 throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∏—Å—å–º–æ: ' + (mailData.message || 'Unknown error') + '\n–ù–æ —Å—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞: ' + upData.link);
             }

         } catch (e) {
             console.error(e);
             alert('‚ùå –û—à–∏–±–∫–∞: ' + e.message);
             setStatus('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏');
         }
      });
      
      function blobToBase64(blob) {
        return new Promise((resolve, _) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
      }

      // Check current URL to hide widget on frontend
          const blob = new Blob([filledPdfBytes], { type: 'application/pdf' });
          const fd = new FormData();
          fd.append('file', blob, 'contract.pdf');
          
          const headers = getHeaders();
          const upRes = await fetch('/api/api.php?action=uploadcontract', { method: 'POST', body: fd, headers });
          const upData = await upRes.json();
          
          if (!upData.success) throw new Error(upData.message);
          
          const emailRes = await fetch('/api/api.php?action=sendContractPdf', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...headers },
            body: JSON.stringify({
              data: { buyerEmail: email }, 
              pdfTemplate: upData.path,
              useUploadedPdf: true
            })
          });
          
          const emailData = await emailRes.json();
          if (emailData.success) {
            setStatus(`‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!`);
            alert(`‚úÖ –î–æ–≥–æ–≤–æ—Ä —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ ${email}`);
          } else {
            throw new Error(emailData.message);
          }
        } catch (err) {
          setStatus('‚ùå ' + err.message);
          alert('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: ' + err.message);
        }
      });
    })();
    </script>
  </body>
</html>
  </body>
</html>
